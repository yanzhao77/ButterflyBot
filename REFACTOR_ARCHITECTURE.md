# ButterflyBot é‡æ„æ¶æ„è®¾è®¡

## ğŸ¯ é‡æ„ç›®æ ‡

1. **ç”Ÿäº§çº§æ¶æ„** - å¯éƒ¨ç½²åœ¨æœåŠ¡å™¨ä¸ŠæŒç»­è¿è¡Œ
2. **BrokeræŠ½è±¡å±‚** - ç»Ÿä¸€æ¥å£ï¼Œæ”¯æŒå›æµ‹/æ¨¡æ‹Ÿ/å®ç›˜åˆ‡æ¢
3. **æ°¸ç»­åˆçº¦æ”¯æŒ** - USDT-M / COIN-M æ°¸ç»­åˆçº¦
4. **æ æ†äº¤æ˜“** - å¯é…ç½®æ æ†å€æ•°
5. **ç¡¬æ€§æ­¢æŸ** - è´¦æˆ·å›æ’¤15%è‡ªåŠ¨æš‚åœ
6. **å®˜æ–¹SDK** - binance-connector + binance-futures-connector
7. **å®Œæ•´æµ‹è¯•** - å›æµ‹å’Œå®ç›˜æµ‹è¯•
8. **è¯¦ç»†æŠ¥å‘Š** - äº¤æ˜“é¢‘ç‡ã€å‡†ç¡®ç‡ã€æœ€å¤§å›æ’¤åˆ†æ

---

## ğŸ“ æ–°æ¶æ„è®¾è®¡

### æ•´ä½“æ¶æ„

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    ButterflyBot v2.0                        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚              Trading Engine (äº¤æ˜“å¼•æ“)                 â”‚ â”‚
â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤ â”‚
â”‚  â”‚  - ç­–ç•¥æ‰§è¡Œ                                           â”‚ â”‚
â”‚  â”‚  - ä¿¡å·ç”Ÿæˆ                                           â”‚ â”‚
â”‚  â”‚  - è®¢å•ç®¡ç†                                           â”‚ â”‚
â”‚  â”‚  - çŠ¶æ€æŒä¹…åŒ–                                         â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                          â†“â†‘                                 â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚              Broker Interface (ç»çºªå•†æ¥å£)             â”‚ â”‚
â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤ â”‚
â”‚  â”‚  æŠ½è±¡å±‚ï¼šç»Ÿä¸€æ¥å£                                      â”‚ â”‚
â”‚  â”‚  - get_balance()                                      â”‚ â”‚
â”‚  â”‚  - get_position()                                     â”‚ â”‚
â”‚  â”‚  â”‚  - place_order()                                     â”‚ â”‚
â”‚  â”‚  - get_klines()                                       â”‚ â”‚
â”‚  â”‚  - set_leverage()                                     â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚           â†“                â†“                â†“               â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”        â”‚
â”‚  â”‚  Backtest   â”‚  â”‚   Paper     â”‚  â”‚    Live     â”‚        â”‚
â”‚  â”‚   Broker    â”‚  â”‚   Broker    â”‚  â”‚   Broker    â”‚        â”‚
â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤        â”‚
â”‚  â”‚ å†å²æ•°æ®    â”‚  â”‚ æ¨¡æ‹Ÿè´¦æˆ·    â”‚  â”‚ çœŸå®API     â”‚        â”‚
â”‚  â”‚ æ¨¡æ‹Ÿæ’®åˆ    â”‚  â”‚ å®æ—¶æ•°æ®    â”‚  â”‚ å®æ—¶äº¤æ˜“    â”‚        â”‚
â”‚  â”‚ æ— å»¶è¿Ÿ      â”‚  â”‚ æ¨¡æ‹Ÿå»¶è¿Ÿ    â”‚  â”‚ çœŸå®å»¶è¿Ÿ    â”‚        â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜        â”‚
â”‚                                                             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚           Risk Manager (é£é™©ç®¡ç†å™¨)                    â”‚ â”‚
â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤ â”‚
â”‚  â”‚  - è´¦æˆ·å›æ’¤ç›‘æ§ï¼ˆç¡¬æ€§æ­¢æŸ15%ï¼‰                         â”‚ â”‚
â”‚  â”‚  - å•ç¬”é£é™©æ§åˆ¶                                        â”‚ â”‚
â”‚  â”‚  - æ æ†å€æ•°é™åˆ¶                                        â”‚ â”‚
â”‚  â”‚  - æŒä»“æ¯”ä¾‹é™åˆ¶                                        â”‚ â”‚
â”‚  â”‚  - è¿ç»­äºæŸä¿æŠ¤                                        â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                                             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚           Reporter (æŠ¥å‘Šç”Ÿæˆå™¨)                        â”‚ â”‚
â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤ â”‚
â”‚  â”‚  - äº¤æ˜“é¢‘ç‡åˆ†æ                                        â”‚ â”‚
â”‚  â”‚  - é¢„æµ‹å‡†ç¡®ç‡ç»Ÿè®¡                                      â”‚ â”‚
â”‚  â”‚  - æœ€å¤§å›æ’¤è®¡ç®—                                        â”‚ â”‚
â”‚  â”‚  - ç›ˆäºæ¯”åˆ†æ                                          â”‚ â”‚
â”‚  â”‚  - åšå¤š/åšç©ºåˆ†æ                                       â”‚ â”‚
â”‚  â”‚  - æ æ†æ•ˆæœåˆ†æ                                        â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸ”§ æ ¸å¿ƒæ¨¡å—è®¾è®¡

### 1. Broker æŠ½è±¡å±‚

**ç›®çš„ï¼š** ç»Ÿä¸€å›æµ‹ã€æ¨¡æ‹Ÿã€å®ç›˜çš„æ¥å£ï¼Œæ–¹ä¾¿åˆ‡æ¢å’Œæµ‹è¯•

```python
from abc import ABC, abstractmethod
from typing import Dict, List, Optional
from enum import Enum

class OrderSide(Enum):
    BUY = "buy"
    SELL = "sell"

class OrderType(Enum):
    MARKET = "market"
    LIMIT = "limit"

class ContractType(Enum):
    SPOT = "spot"              # ç°è´§
    USDT_M = "usdt_m"          # USDTæœ¬ä½æ°¸ç»­
    COIN_M = "coin_m"          # å¸æœ¬ä½æ°¸ç»­

class BaseBroker(ABC):
    """ç»çºªå•†æŠ½è±¡åŸºç±»"""
    
    @abstractmethod
    def get_balance(self, asset: str = "USDT") -> float:
        """è·å–ä½™é¢"""
        pass
    
    @abstractmethod
    def get_position(self, symbol: str) -> Dict:
        """è·å–æŒä»“
        Returns:
            {
                'size': float,        # æŒä»“æ•°é‡ï¼ˆæ­£=å¤šï¼Œè´Ÿ=ç©ºï¼‰
                'entry_price': float, # å¼€ä»“å‡ä»·
                'leverage': int,      # æ æ†å€æ•°
                'unrealized_pnl': float,  # æœªå®ç°ç›ˆäº
            }
        """
        pass
    
    @abstractmethod
    def place_order(
        self,
        symbol: str,
        side: OrderSide,
        amount: float,
        order_type: OrderType = OrderType.MARKET,
        price: Optional[float] = None
    ) -> Dict:
        """ä¸‹å•
        Returns:
            {
                'order_id': str,
                'filled_price': float,
                'filled_amount': float,
                'fee': float,
            }
        """
        pass
    
    @abstractmethod
    def get_klines(
        self,
        symbol: str,
        interval: str,
        limit: int = 500
    ) -> pd.DataFrame:
        """è·å–Kçº¿æ•°æ®"""
        pass
    
    @abstractmethod
    def set_leverage(self, symbol: str, leverage: int):
        """è®¾ç½®æ æ†å€æ•°ï¼ˆä»…æ°¸ç»­åˆçº¦ï¼‰"""
        pass
    
    @abstractmethod
    def close_position(self, symbol: str):
        """å¹³ä»“"""
        pass
```

### 2. Broker å®ç°ç±»

#### BacktestBrokerï¼ˆå›æµ‹ï¼‰

```python
class BacktestBroker(BaseBroker):
    """å›æµ‹ç»çºªå•†
    
    ç‰¹ç‚¹ï¼š
    - ä½¿ç”¨å†å²æ•°æ®
    - æ¨¡æ‹Ÿè®¢å•æ’®åˆ
    - æ— ç½‘ç»œå»¶è¿Ÿ
    - ç²¾ç¡®è®¡ç®—æ‰‹ç»­è´¹å’Œæ»‘ç‚¹
    """
    
    def __init__(
        self,
        initial_balance: float = 1000.0,
        commission: float = 0.001,  # 0.1%
        slippage: float = 0.0005,   # 0.05%
        contract_type: ContractType = ContractType.SPOT
    ):
        self.balance = initial_balance
        self.initial_balance = initial_balance
        self.positions = {}
        self.orders = []
        self.trades = []
        self.commission = commission
        self.slippage = slippage
        self.contract_type = contract_type
        self.leverage = 1
        
        # å†å²æ•°æ®
        self.klines_data = {}
        self.current_index = 0
    
    def load_historical_data(self, symbol: str, df: pd.DataFrame):
        """åŠ è½½å†å²æ•°æ®"""
        self.klines_data[symbol] = df
    
    def step(self):
        """æ¨è¿›ä¸€ä¸ªæ—¶é—´æ­¥ï¼ˆç”¨äºå›æµ‹å¾ªç¯ï¼‰"""
        self.current_index += 1
    
    def get_current_price(self, symbol: str) -> float:
        """è·å–å½“å‰ä»·æ ¼"""
        df = self.klines_data[symbol]
        return df.iloc[self.current_index]['close']
    
    def place_order(self, symbol, side, amount, order_type=OrderType.MARKET, price=None):
        """æ¨¡æ‹Ÿä¸‹å•"""
        current_price = self.get_current_price(symbol)
        
        # æ¨¡æ‹Ÿæ»‘ç‚¹
        if side == OrderSide.BUY:
            filled_price = current_price * (1 + self.slippage)
        else:
            filled_price = current_price * (1 - self.slippage)
        
        # è®¡ç®—æ‰‹ç»­è´¹
        cost = filled_price * amount
        fee = cost * self.commission
        
        # æ›´æ–°ä½™é¢å’ŒæŒä»“
        if side == OrderSide.BUY:
            required = cost + fee
            if self.contract_type == ContractType.SPOT:
                if required > self.balance:
                    raise ValueError(f"ä½™é¢ä¸è¶³: {self.balance} < {required}")
                self.balance -= required
            else:  # æ°¸ç»­åˆçº¦
                margin = required / self.leverage
                if margin > self.balance:
                    raise ValueError(f"ä¿è¯é‡‘ä¸è¶³: {self.balance} < {margin}")
                self.balance -= fee  # åªæ‰£æ‰‹ç»­è´¹
            
            # æ›´æ–°æŒä»“
            if symbol not in self.positions:
                self.positions[symbol] = {
                    'size': 0,
                    'entry_price': 0,
                    'leverage': self.leverage
                }
            
            pos = self.positions[symbol]
            total_cost = pos['size'] * pos['entry_price'] + amount * filled_price
            pos['size'] += amount
            pos['entry_price'] = total_cost / pos['size'] if pos['size'] > 0 else 0
        
        else:  # SELL
            # å¹³ä»“é€»è¾‘
            if symbol in self.positions:
                pos = self.positions[symbol]
                if amount > pos['size']:
                    amount = pos['size']
                
                # è®¡ç®—ç›ˆäº
                if self.contract_type == ContractType.SPOT:
                    pnl = (filled_price - pos['entry_price']) * amount - fee
                    self.balance += filled_price * amount - fee
                else:  # æ°¸ç»­åˆçº¦
                    pnl = (filled_price - pos['entry_price']) * amount * self.leverage - fee
                    self.balance += pnl
                
                pos['size'] -= amount
                if pos['size'] <= 0:
                    del self.positions[symbol]
        
        # è®°å½•äº¤æ˜“
        trade = {
            'timestamp': self.klines_data[symbol].index[self.current_index],
            'symbol': symbol,
            'side': side.value,
            'amount': amount,
            'price': filled_price,
            'fee': fee,
            'balance': self.balance
        }
        self.trades.append(trade)
        
        return {
            'order_id': f"backtest_{len(self.trades)}",
            'filled_price': filled_price,
            'filled_amount': amount,
            'fee': fee
        }
```

#### PaperBrokerï¼ˆæ¨¡æ‹Ÿç›˜ï¼‰

```python
class PaperBroker(BaseBroker):
    """æ¨¡æ‹Ÿç›˜ç»çºªå•†
    
    ç‰¹ç‚¹ï¼š
    - ä½¿ç”¨å®æ—¶æ•°æ®
    - æ¨¡æ‹Ÿè´¦æˆ·
    - æ¨¡æ‹Ÿå»¶è¿Ÿ
    - ä¸æ¶ˆè€—çœŸå®èµ„é‡‘
    """
    
    def __init__(
        self,
        initial_balance: float = 1000.0,
        contract_type: ContractType = ContractType.SPOT
    ):
        self.balance = initial_balance
        self.initial_balance = initial_balance
        self.positions = {}
        self.orders = []
        self.trades = []
        self.contract_type = contract_type
        self.leverage = 1
        
        # ä½¿ç”¨çœŸå®APIè·å–æ•°æ®ï¼ˆä½†ä¸äº¤æ˜“ï¼‰
        from binance.spot import Spot
        self.client = Spot()
    
    def get_klines(self, symbol, interval, limit=500):
        """è·å–å®æ—¶Kçº¿"""
        # è½¬æ¢ç¬¦å·æ ¼å¼
        binance_symbol = symbol.replace('/', '')
        klines = self.client.klines(binance_symbol, interval, limit=limit)
        
        df = pd.DataFrame(klines, columns=[
            'timestamp', 'open', 'high', 'low', 'close', 'volume',
            'close_time', 'quote_volume', 'trades', 'taker_buy_base',
            'taker_buy_quote', 'ignore'
        ])
        
        df['timestamp'] = pd.to_datetime(df['timestamp'], unit='ms')
        df = df.set_index('timestamp')
        df = df[['open', 'high', 'low', 'close', 'volume']].astype(float)
        
        return df
    
    def place_order(self, symbol, side, amount, order_type=OrderType.MARKET, price=None):
        """æ¨¡æ‹Ÿä¸‹å•ï¼ˆä¸æ‰§è¡ŒçœŸå®äº¤æ˜“ï¼‰"""
        # è·å–å½“å‰ä»·æ ¼
        binance_symbol = symbol.replace('/', '')
        ticker = self.client.ticker_price(binance_symbol)
        current_price = float(ticker['price'])
        
        # æ¨¡æ‹Ÿæ»‘ç‚¹å’Œæ‰‹ç»­è´¹
        slippage = 0.0005
        commission = 0.001
        
        if side == OrderSide.BUY:
            filled_price = current_price * (1 + slippage)
        else:
            filled_price = current_price * (1 - slippage)
        
        cost = filled_price * amount
        fee = cost * commission
        
        # æ›´æ–°æ¨¡æ‹Ÿè´¦æˆ·ï¼ˆé€»è¾‘åŒBacktestBrokerï¼‰
        # ... (çœç•¥ï¼Œä¸BacktestBrokerç›¸åŒ)
        
        return {
            'order_id': f"paper_{len(self.trades)}",
            'filled_price': filled_price,
            'filled_amount': amount,
            'fee': fee
        }
```

#### LiveBrokerï¼ˆå®ç›˜ï¼‰

```python
class LiveBroker(BaseBroker):
    """å®ç›˜ç»çºªå•†
    
    ç‰¹ç‚¹ï¼š
    - çœŸå®API
    - çœŸå®äº¤æ˜“
    - çœŸå®å»¶è¿Ÿ
    - æ¶ˆè€—çœŸå®èµ„é‡‘
    """
    
    def __init__(
        self,
        api_key: str,
        api_secret: str,
        contract_type: ContractType = ContractType.SPOT,
        testnet: bool = False
    ):
        self.api_key = api_key
        self.api_secret = api_secret
        self.contract_type = contract_type
        self.testnet = testnet
        
        # æ ¹æ®åˆçº¦ç±»å‹é€‰æ‹©å®¢æˆ·ç«¯
        if contract_type == ContractType.SPOT:
            from binance.spot import Spot
            self.client = Spot(
                api_key=api_key,
                api_secret=api_secret,
                base_url="https://testnet.binance.vision" if testnet else None
            )
        elif contract_type == ContractType.USDT_M:
            from binance.um_futures import UMFutures
            self.client = UMFutures(
                key=api_key,
                secret=api_secret,
                base_url="https://testnet.binancefuture.com" if testnet else None
            )
        elif contract_type == ContractType.COIN_M:
            from binance.cm_futures import CMFutures
            self.client = CMFutures(
                key=api_key,
                secret=api_secret
            )
    
    def get_balance(self, asset="USDT"):
        """è·å–çœŸå®ä½™é¢"""
        if self.contract_type == ContractType.SPOT:
            account = self.client.account()
            for balance in account['balances']:
                if balance['asset'] == asset:
                    return float(balance['free'])
        else:  # æ°¸ç»­åˆçº¦
            account = self.client.account()
            for asset_info in account['assets']:
                if asset_info['asset'] == asset:
                    return float(asset_info['availableBalance'])
        return 0.0
    
    def get_position(self, symbol):
        """è·å–çœŸå®æŒä»“"""
        if self.contract_type == ContractType.SPOT:
            # ç°è´§æ²¡æœ‰æŒä»“æ¦‚å¿µ
            base = symbol.split('/')[0]
            balance = self.get_balance(base)
            return {
                'size': balance,
                'entry_price': 0,
                'leverage': 1,
                'unrealized_pnl': 0
            }
        else:  # æ°¸ç»­åˆçº¦
            binance_symbol = symbol.replace('/', '')
            positions = self.client.get_position_risk(symbol=binance_symbol)
            for pos in positions:
                if pos['symbol'] == binance_symbol:
                    return {
                        'size': float(pos['positionAmt']),
                        'entry_price': float(pos['entryPrice']),
                        'leverage': int(pos['leverage']),
                        'unrealized_pnl': float(pos['unRealizedProfit'])
                    }
        return {'size': 0, 'entry_price': 0, 'leverage': 1, 'unrealized_pnl': 0}
    
    def place_order(self, symbol, side, amount, order_type=OrderType.MARKET, price=None):
        """æ‰§è¡ŒçœŸå®äº¤æ˜“"""
        binance_symbol = symbol.replace('/', '')
        
        params = {
            'symbol': binance_symbol,
            'side': side.value.upper(),
            'type': order_type.value.upper(),
            'quantity': amount
        }
        
        if order_type == OrderType.LIMIT and price:
            params['price'] = price
            params['timeInForce'] = 'GTC'
        
        # æ‰§è¡Œè®¢å•
        if self.contract_type == ContractType.SPOT:
            order = self.client.new_order(**params)
        else:  # æ°¸ç»­åˆçº¦
            order = self.client.new_order(**params)
        
        return {
            'order_id': order['orderId'],
            'filled_price': float(order.get('avgPrice', price or 0)),
            'filled_amount': float(order.get('executedQty', amount)),
            'fee': 0  # éœ€è¦å•ç‹¬æŸ¥è¯¢
        }
    
    def set_leverage(self, symbol, leverage):
        """è®¾ç½®æ æ†ï¼ˆä»…æ°¸ç»­åˆçº¦ï¼‰"""
        if self.contract_type in [ContractType.USDT_M, ContractType.COIN_M]:
            binance_symbol = symbol.replace('/', '')
            self.client.change_leverage(symbol=binance_symbol, leverage=leverage)
```

---

### 3. RiskManagerï¼ˆé£é™©ç®¡ç†å™¨ï¼‰

```python
class RiskManager:
    """é£é™©ç®¡ç†å™¨
    
    åŠŸèƒ½ï¼š
    1. è´¦æˆ·å›æ’¤ç›‘æ§ï¼ˆç¡¬æ€§æ­¢æŸï¼‰
    2. å•ç¬”é£é™©æ§åˆ¶
    3. æ æ†å€æ•°é™åˆ¶
    4. æŒä»“æ¯”ä¾‹é™åˆ¶
    5. è¿ç»­äºæŸä¿æŠ¤
    """
    
    def __init__(
        self,
        initial_balance: float,
        max_drawdown_pct: float = 0.15,  # æœ€å¤§å›æ’¤15%
        max_position_ratio: float = 0.25,  # æœ€å¤§ä»“ä½25%
        max_leverage: int = 5,  # æœ€å¤§æ æ†5å€
        max_consecutive_losses: int = 5  # æœ€å¤§è¿ç»­äºæŸ5æ¬¡
    ):
        self.initial_balance = initial_balance
        self.peak_balance = initial_balance
        self.current_balance = initial_balance
        
        self.max_drawdown_pct = max_drawdown_pct
        self.max_position_ratio = max_position_ratio
        self.max_leverage = max_leverage
        self.max_consecutive_losses = max_consecutive_losses
        
        self.consecutive_losses = 0
        self.is_paused = False
        self.pause_reason = ""
    
    def update_balance(self, balance: float):
        """æ›´æ–°ä½™é¢"""
        self.current_balance = balance
        if balance > self.peak_balance:
            self.peak_balance = balance
    
    def get_current_drawdown(self) -> float:
        """è®¡ç®—å½“å‰å›æ’¤"""
        return (self.peak_balance - self.current_balance) / self.peak_balance
    
    def check_hard_stop(self) -> bool:
        """æ£€æŸ¥ç¡¬æ€§æ­¢æŸ"""
        drawdown = self.get_current_drawdown()
        
        if drawdown >= self.max_drawdown_pct:
            self.is_paused = True
            self.pause_reason = f"è´¦æˆ·å›æ’¤{drawdown:.2%}è¶…è¿‡é™åˆ¶{self.max_drawdown_pct:.2%}"
            return True
        
        return False
    
    def check_position_size(self, position_value: float) -> bool:
        """æ£€æŸ¥ä»“ä½å¤§å°"""
        ratio = position_value / self.current_balance
        if ratio > self.max_position_ratio:
            return False
        return True
    
    def check_leverage(self, leverage: int) -> bool:
        """æ£€æŸ¥æ æ†å€æ•°"""
        return leverage <= self.max_leverage
    
    def record_trade_result(self, pnl: float):
        """è®°å½•äº¤æ˜“ç»“æœ"""
        if pnl < 0:
            self.consecutive_losses += 1
        else:
            self.consecutive_losses = 0
        
        if self.consecutive_losses >= self.max_consecutive_losses:
            self.is_paused = True
            self.pause_reason = f"è¿ç»­äºæŸ{self.consecutive_losses}æ¬¡"
    
    def can_trade(self) -> tuple[bool, str]:
        """æ˜¯å¦å¯ä»¥äº¤æ˜“"""
        if self.is_paused:
            return False, self.pause_reason
        
        if self.check_hard_stop():
            return False, self.pause_reason
        
        return True, ""
```

---

### 4. Reporterï¼ˆæŠ¥å‘Šç”Ÿæˆå™¨ï¼‰

```python
class Reporter:
    """æŠ¥å‘Šç”Ÿæˆå™¨
    
    ç”Ÿæˆè¯¦ç»†çš„äº¤æ˜“æŠ¥å‘Šï¼ŒåŒ…æ‹¬ï¼š
    - äº¤æ˜“é¢‘ç‡åˆ†æ
    - é¢„æµ‹å‡†ç¡®ç‡ç»Ÿè®¡
    - æœ€å¤§å›æ’¤è®¡ç®—
    - ç›ˆäºæ¯”åˆ†æ
    - åšå¤š/åšç©ºåˆ†æ
    - æ æ†æ•ˆæœåˆ†æ
    """
    
    def __init__(self, trades: List[Dict], initial_balance: float):
        self.trades = pd.DataFrame(trades)
        self.initial_balance = initial_balance
    
    def generate_report(self) -> Dict:
        """ç”Ÿæˆå®Œæ•´æŠ¥å‘Š"""
        report = {
            'summary': self._summary_stats(),
            'frequency': self._frequency_analysis(),
            'accuracy': self._accuracy_analysis(),
            'drawdown': self._drawdown_analysis(),
            'profit_loss': self._profit_loss_analysis(),
            'direction': self._direction_analysis(),
            'leverage': self._leverage_analysis()
        }
        
        return report
    
    def _summary_stats(self) -> Dict:
        """æ€»ä½“ç»Ÿè®¡"""
        final_balance = self.trades['balance'].iloc[-1]
        total_return = (final_balance - self.initial_balance) / self.initial_balance
        
        return {
            'initial_balance': self.initial_balance,
            'final_balance': final_balance,
            'total_return': total_return,
            'total_trades': len(self.trades),
            'winning_trades': len(self.trades[self.trades['pnl'] > 0]),
            'losing_trades': len(self.trades[self.trades['pnl'] < 0]),
            'win_rate': len(self.trades[self.trades['pnl'] > 0]) / len(self.trades)
        }
    
    def _frequency_analysis(self) -> Dict:
        """äº¤æ˜“é¢‘ç‡åˆ†æ"""
        # è®¡ç®—äº¤æ˜“é—´éš”
        self.trades['timestamp'] = pd.to_datetime(self.trades['timestamp'])
        intervals = self.trades['timestamp'].diff().dt.total_seconds() / 3600  # å°æ—¶
        
        return {
            'avg_interval_hours': intervals.mean(),
            'median_interval_hours': intervals.median(),
            'min_interval_hours': intervals.min(),
            'max_interval_hours': intervals.max(),
            'trades_per_day': len(self.trades) / (intervals.sum() / 24)
        }
    
    def _accuracy_analysis(self) -> Dict:
        """é¢„æµ‹å‡†ç¡®ç‡åˆ†æ"""
        # å‡è®¾tradesä¸­æœ‰'predicted'å’Œ'actual'å­—æ®µ
        if 'predicted' in self.trades.columns and 'actual' in self.trades.columns:
            correct = (self.trades['predicted'] == self.trades['actual']).sum()
            accuracy = correct / len(self.trades)
            
            return {
                'accuracy': accuracy,
                'correct_predictions': correct,
                'total_predictions': len(self.trades)
            }
        return {}
    
    def _drawdown_analysis(self) -> Dict:
        """å›æ’¤åˆ†æ"""
        equity = self.trades['balance']
        peak = equity.expanding().max()
        drawdown = (peak - equity) / peak
        
        max_dd = drawdown.max()
        max_dd_idx = drawdown.idxmax()
        max_dd_date = self.trades.loc[max_dd_idx, 'timestamp']
        
        return {
            'max_drawdown': max_dd,
            'max_drawdown_date': max_dd_date,
            'avg_drawdown': drawdown.mean()
        }
    
    def _profit_loss_analysis(self) -> Dict:
        """ç›ˆäºåˆ†æ"""
        wins = self.trades[self.trades['pnl'] > 0]['pnl']
        losses = self.trades[self.trades['pnl'] < 0]['pnl']
        
        return {
            'avg_win': wins.mean() if len(wins) > 0 else 0,
            'avg_loss': losses.mean() if len(losses) > 0 else 0,
            'profit_factor': abs(wins.sum() / losses.sum()) if len(losses) > 0 else float('inf'),
            'expectancy': self.trades['pnl'].mean()
        }
    
    def _direction_analysis(self) -> Dict:
        """åšå¤š/åšç©ºåˆ†æ"""
        longs = self.trades[self.trades['side'] == 'buy']
        shorts = self.trades[self.trades['side'] == 'sell']
        
        return {
            'long_trades': len(longs),
            'short_trades': len(shorts),
            'long_win_rate': len(longs[longs['pnl'] > 0]) / len(longs) if len(longs) > 0 else 0,
            'short_win_rate': len(shorts[shorts['pnl'] > 0]) / len(shorts) if len(shorts) > 0 else 0,
            'long_pnl': longs['pnl'].sum() if len(longs) > 0 else 0,
            'short_pnl': shorts['pnl'].sum() if len(shorts) > 0 else 0
        }
    
    def _leverage_analysis(self) -> Dict:
        """æ æ†æ•ˆæœåˆ†æ"""
        if 'leverage' in self.trades.columns:
            return {
                'avg_leverage': self.trades['leverage'].mean(),
                'max_leverage': self.trades['leverage'].max(),
                'leverage_distribution': self.trades['leverage'].value_counts().to_dict()
            }
        return {}
```

---

## ğŸ“‚ æ–°ç›®å½•ç»“æ„

```
ButterflyBot/
â”œâ”€â”€ core/                          # æ ¸å¿ƒæ¨¡å—
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ broker/                    # BrokeræŠ½è±¡å±‚
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ base.py               # BaseBrokeræŠ½è±¡ç±»
â”‚   â”‚   â”œâ”€â”€ backtest.py           # BacktestBroker
â”‚   â”‚   â”œâ”€â”€ paper.py              # PaperBroker
â”‚   â”‚   â””â”€â”€ live.py               # LiveBroker
â”‚   â”œâ”€â”€ engine/                    # äº¤æ˜“å¼•æ“
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ trading_engine.py     # ä¸»å¼•æ“
â”‚   â”‚   â””â”€â”€ order_manager.py      # è®¢å•ç®¡ç†
â”‚   â”œâ”€â”€ risk/                      # é£é™©ç®¡ç†
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â””â”€â”€ risk_manager.py       # RiskManager
â”‚   â””â”€â”€ reporter/                  # æŠ¥å‘Šç”Ÿæˆ
â”‚       â”œâ”€â”€ __init__.py
â”‚       â””â”€â”€ reporter.py            # Reporter
â”‚
â”œâ”€â”€ strategies/                    # ç­–ç•¥æ¨¡å—
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ ai_signal_core.py         # AIä¿¡å·ç­–ç•¥ï¼ˆä¿ç•™ï¼‰
â”‚   â””â”€â”€ base_strategy.py          # ç­–ç•¥åŸºç±»
â”‚
â”œâ”€â”€ model/                         # æ¨¡å‹æ¨¡å—ï¼ˆä¿ç•™ï¼‰
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ lgb_model.py
â”‚   â””â”€â”€ train_balanced.py
â”‚
â”œâ”€â”€ data/                          # æ•°æ®æ¨¡å—ï¼ˆä¿ç•™ï¼‰
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ features.py
â”‚   â””â”€â”€ fetcher.py
â”‚
â”œâ”€â”€ config/                        # é…ç½®æ¨¡å—
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ settings.py               # åŸºç¡€é…ç½®
â”‚   â”œâ”€â”€ backtest_config.py        # å›æµ‹é…ç½®
â”‚   â”œâ”€â”€ paper_config.py           # æ¨¡æ‹Ÿç›˜é…ç½®
â”‚   â””â”€â”€ live_config.py            # å®ç›˜é…ç½®
â”‚
â”œâ”€â”€ scripts/                       # è¿è¡Œè„šæœ¬
â”‚   â”œâ”€â”€ run_backtest.py           # è¿è¡Œå›æµ‹
â”‚   â”œâ”€â”€ run_paper.py              # è¿è¡Œæ¨¡æ‹Ÿç›˜
â”‚   â””â”€â”€ run_live.py               # è¿è¡Œå®ç›˜
â”‚
â”œâ”€â”€ tests/                         # æµ‹è¯•æ¨¡å—
â”‚   â”œâ”€â”€ test_broker.py
â”‚   â”œâ”€â”€ test_risk_manager.py
â”‚   â””â”€â”€ test_reporter.py
â”‚
â”œâ”€â”€ reports/                       # æŠ¥å‘Šè¾“å‡º
â”‚   â”œâ”€â”€ backtest/
â”‚   â”œâ”€â”€ paper/
â”‚   â””â”€â”€ live/
â”‚
â”œâ”€â”€ requirements.txt
â””â”€â”€ README.md
```

---

## ğŸš€ ä½¿ç”¨æµç¨‹

### 1. å›æµ‹

```python
from core.broker.backtest import BacktestBroker, ContractType
from core.engine.trading_engine import TradingEngine
from strategies.ai_signal_core import AISignalCore

# åˆ›å»ºå›æµ‹Broker
broker = BacktestBroker(
    initial_balance=1000,
    contract_type=ContractType.USDT_M,  # ä½¿ç”¨USDTæœ¬ä½æ°¸ç»­
    commission=0.001,
    slippage=0.0005
)

# è®¾ç½®æ æ†
broker.set_leverage("DOGE/USDT", 5)

# åŠ è½½å†å²æ•°æ®
df = pd.read_csv('data.csv')
broker.load_historical_data("DOGE/USDT", df)

# åˆ›å»ºç­–ç•¥
strategy = AISignalCore(...)

# åˆ›å»ºäº¤æ˜“å¼•æ“
engine = TradingEngine(broker, strategy)

# è¿è¡Œå›æµ‹
engine.run_backtest()

# ç”ŸæˆæŠ¥å‘Š
report = engine.generate_report()
print(report)
```

### 2. æ¨¡æ‹Ÿç›˜

```python
from core.broker.paper import PaperBroker

# åˆ›å»ºæ¨¡æ‹Ÿç›˜Broker
broker = PaperBroker(
    initial_balance=1000,
    contract_type=ContractType.USDT_M
)

# å…¶ä½™åŒå›æµ‹
engine = TradingEngine(broker, strategy)
engine.run_live()  # æŒç»­è¿è¡Œ
```

### 3. å®ç›˜

```python
from core.broker.live import LiveBroker

# åˆ›å»ºå®ç›˜Broker
broker = LiveBroker(
    api_key="xxx",
    api_secret="xxx",
    contract_type=ContractType.USDT_M,
    testnet=False  # ä½¿ç”¨çœŸå®ç¯å¢ƒ
)

# å…¶ä½™åŒæ¨¡æ‹Ÿç›˜
engine = TradingEngine(broker, strategy)
engine.run_live()
```

---

## âœ… ä¸‹ä¸€æ­¥å®æ–½è®¡åˆ’

1. **Phase 1ï¼šæ ¸å¿ƒæ¨¡å—å®ç°**
   - BrokeræŠ½è±¡å±‚
   - RiskManager
   - Reporter

2. **Phase 2ï¼šå¼•æ“å®ç°**
   - TradingEngine
   - OrderManager

3. **Phase 3ï¼šæµ‹è¯•**
   - å•å…ƒæµ‹è¯•
   - é›†æˆæµ‹è¯•
   - å›æµ‹éªŒè¯

4. **Phase 4ï¼šéƒ¨ç½²**
   - Dockerå®¹å™¨åŒ–
   - ç›‘æ§å‘Šè­¦
   - æ—¥å¿—ç³»ç»Ÿ

5. **Phase 5ï¼šä¼˜åŒ–**
   - æ€§èƒ½ä¼˜åŒ–
   - ç­–ç•¥ä¼˜åŒ–
   - é£æ§ä¼˜åŒ–
